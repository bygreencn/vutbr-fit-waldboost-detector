/**   
 * @file wb_waldboostdetector.h
 * @brief Waldboost detector.
 *
 * @details Global and device functions (all in wb namespace) and a WaldboostDetector class
 * which uses the as gpu kernels for object detection using waldboost metaalgorithm
 * and LBP features. Only the WaldboostDetector class should be used on its own.
 *
 * @author Pavel Macenauer <macenauer.p@gmail.com>
 */

#ifndef H_WB_WALDBOOSTDETECTOR
#define H_WB_WALDBOOSTDETECTOR

#include "wbd_structures.h"
#include "wbd_general.h"

#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <opencv2/nonfree/features2d.hpp>

namespace wbd 
{
	/** @brief Copies image from a dynamically set texture. */
	__global__ void copyImageFromTextureObject(float* out, cudaTextureObject_t obj, uint32 width, uint32 height);

	/** @brief Clears an image.
	 * 
	 * Sets all floating-point pixels to 0.
	 */
	__global__ void clearKernel(float* data, uint32 width, uint32 height);	

	class WaldboostDetector 
	{
		public:
			/** @brief Constructor. */
			WaldboostDetector();

			/** @brief Initializes the detector.
			 *
			 * @details Initializes the detector based on given image parameters. It's stuff, 
			 * which is called only once for a video or an image, such as gpu memory
			 * allocation
			 *
			 * @param image		Pointer to an image.
			 * @return			Void.
			 */
			void init(cv::Mat* image);

			/** @brief Passes an image to the detector. 
			 *
			 * @details Passes image to the detector and does the preprocessing. This means, it
			 * feeds the image data to the gpu, converts it to float/black and white and 
			 * generates a pyramid image.
			 *
			 * @param image		Pointer to an image.
			 * @return			Void.
			 */
			void setImage(cv::Mat* image);

			/** @brief Processes detections. 
			 *
			 * @details Runs the detector, that means processes detections on a pyramid image
			 * saved in texture memory.
			 *
			 * @return Void.
			 */
			void run();

			/** @brief Cleans up memory. 
			 *			
			 * @return Void.
			 */
			void free();	

            void setSettings(RunSettings const& settings) { _settings = settings; }

			/** @brief Sets the kernel block size. */
			void setBlockSize(KernelType type, uint32 const& x = 32, uint32 const& y = 32, uint32 const& z = 1);

			/** @brief Passes run parameters to the detector. */
			void setRunOptions(uint32 const& options) { _opt = options; }		

			/** @brief Number of processed frames. */
			uint32 getFrameCount() const { return _frame; }

		private:
			/** @brief Precalculates image sizes and offsets horizontally.
			 *
			 * @details Precalculates pyramids in a horizontal manner, that means every pyramid next to each other.
			 *
			 * @return Void.
			 * @todo fix crash
			 */
			void _precalcHorizontalPyramid();

			/** @brief Precalculates image sizes and offsets in a user defined manner.
			 *
			 * @details Precalculates pyramids in a user defined manner. Currently 1st octave is on the left, 2nd
			 * top-right, 3rd bottom-left (right from 1st), 4th bottom-right.
			 *
			 * @return Void.
			 */
			void _precalc4x8Pyramid();

			/** @brief Wrapper around pyramid kernels. 
			 *
			 * @return Void. 
			 */
			void _pyramidKernelWrapper();

			/** @brief Single texture pyramid generation.
			 *
			 * @details Pyramid is generated by creating a single texture canvas, generating the first octave from 
			 * the original preprocessed image and then creating downsapled pyramids from the same texture, 
			 * which leads reads and writes from the same texture. Every octave needs only its width x height
			 * number of threads, that means, that every octave several threads (and blocks) return.
			 *
			 * @return Void.
			 */
			void _pyramidGenSingleTexture();

			/** @brief Bindless texture pyramid generation. 
			 *
			 * @details Pyramid is generated using multiple textures, always downsampling from a previously generated textury.
			 * This leads to reads only from textures. While a new texture is generated, the result is simultaneously
			 * copied to the final texture. Disadvantage of this method is initialization for every texture and
			 * kernel run per octave.
			 *
			 * @return Void.
			 */
			void _pyramidGenBindlessTexture();
			
			/** @brief Clears timers.
			 *
			 * @return Void.
			 */
			void _initTimers();

			/** @brief Recalcs detections. 
			 *
			 * @details Detections are detected on an image containing lots of downsampled images (pyramids). Here we map detected
			 *			positions to the original image.
			 *
			 * @return Void.
			 */
			void _processDetections();

			/** @brief Recals detections. 
			 *
			 * @param detections		Passed array of unprocessed detections.
			 * @param detectionCount	Number of detections to process.
			 */
			void _processDetections(Detection* detections, uint32 const& detectionCount);

			/** CONFIGURATION */
			ImageInfo			_info;				///< image information
			Pyramid				_pyramid;			///< pyramid image information
            RunSettings         _settings;
			uint32				_opt;				///< run options/parameters
			float				_timers[MAX_TIMERS];///< timers			
			dim3				_kernelBlockConfig[MAX_KERNEL_TYPES]; ///< kernel block configuration

			/** DATA ARRAYS USED WITH TEXTURES */
			uint8*				_devOriginalImage;		///< pointer to device original image memory
			float*				_devPreprocessedImage;	///< pointer to device preprocessed image memory					
		    float*				_devPyramidData;					///< pointer to device pyramid memory (used by single texture)
			float*				_devPyramidImage[WB_OCTAVES];		///< pointer to device pyramid memory (used by bindless texture)	

			/* TEXTURE OBJECTS */
			cudaTextureObject_t	_texturePyramidObjects[WB_OCTAVES]; ///< cuda texture objects (used by bindless texture)			
			cudaTextureObject_t _preprocessedImageTexture;			///< Texture with preprocessed frame (black and white float image)
			cudaTextureObject_t _finalPyramidTexture;				///< Texture with subsampled images in a pyramid.
			cudaTextureObject_t _alphasTexture;						///< Texture with detector alpha values.

			/* DEVICE MEMORY */
			float*				_devAlphaBuffer;		///< pointer to device alpha memory
			Detection*			_devDetections;			///< pointer to the detections in device memory
			uint32*				_devDetectionCount;		///< pointer to the number of detections in device memory
			SurvivorData*		_devSurvivors[2];		///< pointers to device survivor memory			
			uint32*				_devSurvivorCount[2];   ///< pointers to device survivor counts

			/** HOST MEMORY */
			cv::Mat*			_myImage;				///< pointer to the original processed image
            cv::Mat             _pyramidImage;          ///< simple implementation of pyramid image
			uint32				_frame;					///< frame counter
	};
}

#endif
